#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import pprint
if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.protocol.TBinaryProtocol import TBinaryProtocol

from worker.filesystem import LocalFilesystem
from worker.filesystem.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
    print('')
    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
    print('')
    print('Functions:')
    print('   ls(string path, bool status, bool glob)')
    print('  FileStatusOrNull status(string path, bool strict)')
    print('  FileContentOrNull content(string path, bool strict)')
    print('  void rm(string path, bool recursive)')
    print('  void copy(string src_path, string dst_path)')
    print('  void rename(string src_path, string dst_path)')
    print('  void set_owner(string path, string owner, string group)')
    print('  void set_permission(string path, string permission)')
    print('  void mkdir(string path, string permission)')
    print('  string open(string path, string mode)')
    print('  void close(string filedesc)')
    print('  void flush(string filedesc)')
    print('  string read(string filedesc, i32 size)')
    print('  string readline(string filedesc)')
    print('   readlines(string filedesc, i32 sizehint)')
    print('  i32 write(string filedesc, string data)')
    print('  i32 writelines(string filedesc,  lines)')
    print('  i32 tell(string filedesc)')
    print('  i32 seek(string filedesc, i32 position)')
    print('  bool readable(string filedesc)')
    print('  bool writable(string filedesc)')
    print('  bool seekable(string filedesc)')
    print('')
    sys.exit(0)

pp = pprint.PrettyPrinter(indent=2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
validate = True
ca_certs = None
keyfile = None
certfile = None
http = False
argi = 1

if sys.argv[argi] == '-h':
    parts = sys.argv[argi + 1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    argi += 2

if sys.argv[argi] == '-u':
    url = urlparse(sys.argv[argi + 1])
    parts = url[1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    else:
        port = 80
    uri = url[2]
    if url[4]:
        uri += '?%s' % url[4]
    http = True
    argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
    framed = True
    argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
    ssl = True
    argi += 1

if sys.argv[argi] == '-novalidate':
    validate = False
    argi += 1

if sys.argv[argi] == '-ca_certs':
    ca_certs = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-keyfile':
    keyfile = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-certfile':
    certfile = sys.argv[argi+1]
    argi += 2

cmd = sys.argv[argi]
args = sys.argv[argi + 1:]

if http:
    transport = THttpClient.THttpClient(host, port, uri)
else:
    if ssl:
        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
    else:
        socket = TSocket.TSocket(host, port)
    if framed:
        transport = TTransport.TFramedTransport(socket)
    else:
        transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol(transport)
client = LocalFilesystem.Client(protocol)
transport.open()

if cmd == 'ls':
    if len(args) != 3:
        print('ls requires 3 args')
        sys.exit(1)
    pp.pprint(client.ls(args[0], eval(args[1]), eval(args[2]),))

elif cmd == 'status':
    if len(args) != 2:
        print('status requires 2 args')
        sys.exit(1)
    pp.pprint(client.status(args[0], eval(args[1]),))

elif cmd == 'content':
    if len(args) != 2:
        print('content requires 2 args')
        sys.exit(1)
    pp.pprint(client.content(args[0], eval(args[1]),))

elif cmd == 'rm':
    if len(args) != 2:
        print('rm requires 2 args')
        sys.exit(1)
    pp.pprint(client.rm(args[0], eval(args[1]),))

elif cmd == 'copy':
    if len(args) != 2:
        print('copy requires 2 args')
        sys.exit(1)
    pp.pprint(client.copy(args[0], args[1],))

elif cmd == 'rename':
    if len(args) != 2:
        print('rename requires 2 args')
        sys.exit(1)
    pp.pprint(client.rename(args[0], args[1],))

elif cmd == 'set_owner':
    if len(args) != 3:
        print('set_owner requires 3 args')
        sys.exit(1)
    pp.pprint(client.set_owner(args[0], args[1], args[2],))

elif cmd == 'set_permission':
    if len(args) != 2:
        print('set_permission requires 2 args')
        sys.exit(1)
    pp.pprint(client.set_permission(args[0], args[1],))

elif cmd == 'mkdir':
    if len(args) != 2:
        print('mkdir requires 2 args')
        sys.exit(1)
    pp.pprint(client.mkdir(args[0], args[1],))

elif cmd == 'open':
    if len(args) != 2:
        print('open requires 2 args')
        sys.exit(1)
    pp.pprint(client.open(args[0], args[1],))

elif cmd == 'close':
    if len(args) != 1:
        print('close requires 1 args')
        sys.exit(1)
    pp.pprint(client.close(args[0],))

elif cmd == 'flush':
    if len(args) != 1:
        print('flush requires 1 args')
        sys.exit(1)
    pp.pprint(client.flush(args[0],))

elif cmd == 'read':
    if len(args) != 2:
        print('read requires 2 args')
        sys.exit(1)
    pp.pprint(client.read(args[0], eval(args[1]),))

elif cmd == 'readline':
    if len(args) != 1:
        print('readline requires 1 args')
        sys.exit(1)
    pp.pprint(client.readline(args[0],))

elif cmd == 'readlines':
    if len(args) != 2:
        print('readlines requires 2 args')
        sys.exit(1)
    pp.pprint(client.readlines(args[0], eval(args[1]),))

elif cmd == 'write':
    if len(args) != 2:
        print('write requires 2 args')
        sys.exit(1)
    pp.pprint(client.write(args[0], args[1],))

elif cmd == 'writelines':
    if len(args) != 2:
        print('writelines requires 2 args')
        sys.exit(1)
    pp.pprint(client.writelines(args[0], eval(args[1]),))

elif cmd == 'tell':
    if len(args) != 1:
        print('tell requires 1 args')
        sys.exit(1)
    pp.pprint(client.tell(args[0],))

elif cmd == 'seek':
    if len(args) != 2:
        print('seek requires 2 args')
        sys.exit(1)
    pp.pprint(client.seek(args[0], eval(args[1]),))

elif cmd == 'readable':
    if len(args) != 1:
        print('readable requires 1 args')
        sys.exit(1)
    pp.pprint(client.readable(args[0],))

elif cmd == 'writable':
    if len(args) != 1:
        print('writable requires 1 args')
        sys.exit(1)
    pp.pprint(client.writable(args[0],))

elif cmd == 'seekable':
    if len(args) != 1:
        print('seekable requires 1 args')
        sys.exit(1)
    pp.pprint(client.seekable(args[0],))

else:
    print('Unrecognized method %s' % cmd)
    sys.exit(1)

transport.close()
